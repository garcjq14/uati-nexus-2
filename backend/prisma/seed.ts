// PrismaClient is auto-generated by Prisma. If IDE shows error, it's a cache issue.
// The code compiles correctly. Restart TypeScript server: Ctrl+Shift+P -> "TypeScript: Restart TS Server"
import { PrismaClient } from '@prisma/client';
import * as bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  console.log('Seeding database...');

  // Create test user
  const hashedPassword = await bcrypt.hash('password123', 10);
  const user = await prisma.user.upsert({
    where: { email: 'alexandre@uati.com' },
    update: {},
    create: {
      email: 'alexandre@uati.com',
      name: 'Alexandre N.',
      password: hashedPassword,
      role: 'STUDENT',
      avatar: 'https://ui-avatars.com/api/?name=Alexandre+N&background=A31F34&color=fff',
    },
  });

  const anaPassword = await bcrypt.hash('AnaGarcia@UATI2024!Secure', 10);
  await prisma.user.upsert({
    where: { email: 'anegarcia@uati.com' },
    update: {
      password: anaPassword,
    },
    create: {
      email: 'anegarcia@uati.com',
      name: 'Ana Garcia',
      password: anaPassword,
      role: 'STUDENT',
      avatar: 'https://ui-avatars.com/api/?name=Ana+Garcia&background=C11E3D&color=fff',
    },
  });

  // Create Curriculum for user
  const csCurriculum = [
    { code: 'CS101', title: 'Fundamentos da Computação', order: 1, progress: 100, status: 'completed', syllabus: 'Introdução aos conceitos fundamentais de computação, arquitetura de computadores, sistemas operacionais e redes básicas.' },
    { code: 'CS102', title: 'Algoritmos e Estruturas', order: 2, progress: 65, status: 'active', syllabus: 'Estruturas de dados, algoritmos de ordenação e busca, complexidade algorítmica, árvores e grafos.' },
    { code: 'CS201', title: 'Arquitetura de Sistemas', order: 3, progress: 0, status: 'locked', syllabus: 'Arquitetura de software, padrões de design, microserviços, APIs RESTful e GraphQL.' },
    { code: 'CS202', title: 'Banco de Dados Avançado', order: 4, progress: 0, status: 'locked', syllabus: 'Modelagem de dados, SQL avançado, NoSQL, otimização de queries e transações.' },
    { code: 'CS301', title: 'Inteligência Artificial', order: 5, progress: 0, status: 'locked', syllabus: 'Machine Learning, Deep Learning, processamento de linguagem natural e visão computacional.' },
  ];

  for (const module of csCurriculum) {
    await prisma.curriculum.create({
      data: {
        userId: user.id,
        code: module.code,
        title: module.title,
        syllabus: module.syllabus,
        order: module.order,
        progress: module.progress,
        status: module.status,
      } as any,
    });
  }

  // Create Projects
  await prisma.project.create({
    data: {
      userId: user.id,
      title: 'CLI Task Manager',
      description: 'Task manager command line interface',
      type: 'Dev',
      status: 'finalizado',
      progress: 100,
      priority: false,
    } as any,
  });

  await prisma.project.create({
    data: {
      userId: user.id,
      title: 'Microservices API',
      description: 'Microservices architecture implementation',
      requirements: 'Implementar uma API de microserviços com:\n- 3 serviços independentes\n- Comunicação via REST\n- Banco de dados por serviço\n- Deploy em containers',
      technologies: JSON.stringify(['Node.js', 'Docker', 'PostgreSQL', 'Redis']),
      deadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
      repository: 'https://github.com/user/microservices-api',
      type: 'Dev',
      status: 'em_progresso',
      progress: 70,
      priority: true,
      tasks: {
        create: [
          { title: 'Pesquisar referências', status: 'done', order: 0 },
          { title: 'Escrever rascunho inicial', status: 'doing', order: 1 },
          { title: 'Implementar serviço de autenticação', status: 'todo', order: 2 },
          { title: 'Configurar Docker Compose', status: 'todo', order: 3 },
        ],
      },
    } as any,
  });

  // Create Flashcards
  const csFlashcards = [
    {
      deck: 'Conceitos Base',
      front: 'Qual a diferença entre Concorrência e Paralelismo?',
      back: 'Concorrência é quando múltiplas tarefas fazem progresso ao mesmo tempo, mas não necessariamente simultaneamente. Paralelismo é quando múltiplas tarefas executam simultaneamente em múltiplos processadores.',
      nextReview: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000), // 2 days ago
    },
    {
      deck: 'Conceitos Base',
      front: 'O que é um algoritmo?',
      back: 'Um algoritmo é um conjunto de instruções passo a passo para resolver um problema ou realizar uma tarefa.',
    },
    {
      deck: 'Vocabulário Técnico',
      front: 'API',
      back: 'Application Programming Interface - Interface que permite comunicação entre diferentes sistemas de software.',
      nextReview: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
    },
  ];

  for (const card of csFlashcards) {
    await prisma.flashcard.create({
      data: {
        userId: user.id,
        deck: card.deck,
        front: card.front,
        back: card.back,
        nextReview: card.nextReview || new Date(),
      } as any,
    });
  }

  // Create Resources
  const csResources = [
    {
      title: 'Deep Work',
      author: 'Cal Newport',
      format: 'Livro',
      status: 'lendo',
    },
    {
      title: 'Atomic Habits',
      author: 'James Clear',
      format: 'Audio',
      status: 'concluido',
    },
    {
      title: 'Documentation V2.0',
      author: 'Wiki',
      format: 'PDF',
      status: 'a_fazer',
    },
  ];

  for (const resource of csResources) {
    await prisma.resource.create({
      data: {
        userId: user.id,
        title: resource.title,
        author: resource.author,
        format: resource.format,
        status: resource.status,
      } as any,
    });
  }

  // Create Knowledge Nodes
  const theoryNode = await prisma.knowledgeNode.create({
    data: {
      userId: user.id,
      label: 'Teoria',
      type: 'theory',
      x: -200,
      y: 0,
    } as any,
  });

  const practiceNode = await prisma.knowledgeNode.create({
    data: {
      userId: user.id,
      label: 'Prática',
      type: 'practice',
      x: 200,
      y: 0,
    } as any,
  });

  const majorNode = await prisma.knowledgeNode.create({
    data: {
      userId: user.id,
      label: 'ENG. SOFTWARE',
      type: 'concept',
      x: 0,
      y: 200,
    } as any,
  });

  // Create connections
  await prisma.nodeConnection.createMany({
    data: [
      { fromNodeId: theoryNode.id, toNodeId: majorNode.id },
      { fromNodeId: practiceNode.id, toNodeId: majorNode.id },
    ],
  });

  // Create study sessions
  await prisma.studySession.create({
    data: {
      userId: user.id,
      duration: 25,
      type: 'pomodoro',
      audio: 'lofi',
    } as any,
  });

  console.log('Database seeded successfully!');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

